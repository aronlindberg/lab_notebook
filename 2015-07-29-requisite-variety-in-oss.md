# Requisite Variety in OSS
The reviewers are commenting that requisite variety is mostly a metaphor when it comes to OSS. For example, in control systems we can simply count the states that the machine needs to match, and then we make sure that machine has the same number of states. This is not how it's going to work in OSS. Rather, as code complexity is being generated (interconnections between files) it needs to be countered by entropy - meaning that higher degrees of code complexity needs a higher variety of activity types in order to counter.

Similarly, as community complexity increases, developers need to iterate across multiple activities, thus increasing the overall complexity, length, as well as heterogeneity of the routine. In this sense requisite variety is metaphorical, but it is also empirically validated.

So, why do the specific matchings that I see in the data occur? Code complexity is mirrored by Entropy, and social complexity is mirrored by heterogeneity and complexity. Entropy is "efficient coverage" - leveraging just the variety that is needed to match a problem. This is possible because all the code is available, and developers can match their activities directly to that code. However, in the case of community-related complexity (or should I possibly use the term variety here?) developers are relating to much more ambiguous sources of complexity (what on Twitter sometimes is referred to as #otherpeoplesdata or #otherpeopleslaptops).

As the complexity of an enactment goes up, the actual technical development process starts to get overwhelmed, and routine complexity is matched to community complexity, so as to achieve shared understandings. This means that complexity is diverted from the actual solving of the code-related problem, and is leveraged to create shared mental models - another important outcome that helps to achieve cognitive cohesion and therefore facilitates future coordination.
